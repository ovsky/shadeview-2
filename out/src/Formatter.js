"use strict"; Object.defineProperty(exports, "__esModule", { value: !0 }); const vscode_1 = require("vscode"), Utilities_1 = require("./Utilities"), ShadeView_1 = require("./ShadeView"), Utilities_2 = require("./Utilities"), MACRO_METHODS_PAIR = { UNITY_INSTANCING_CBUFFER_START: "UNITY_INSTANCING_CBUFFER_END", CBUFFER_START: "CBUFFER_END" }; class IndentationType { } IndentationType.identWithHierachy = "Indentation with hierachy", IndentationType.noIndentWithHierachy = "No Indentation but with hierachy", IndentationType.indentWithoutHierachy = "Indentation without hierachy", IndentationType.noIndentWithoutHierachy = "No Indentation and without hierachy"; class Formatter {
    constructor(t, e = 4, i = !0, r = "1", a = !0, s = !0) { this.tabs = t, this.tabSize = e, this.placeBraceOnNewLine = i, this.alignMacroMode = r, this.singleLineTags = a, this.keepMacroMethodsLevel = s, this.CommentPattern = /((\/\/.+)|(\/\*[\s\S]*?\*\/))/gm, this.StringPattern = /"[^\n]*?(?<!\\)"/gm } formatDocument(t) { let e = ShadeView_1.ShadeView.getCodeSegments(t.getText()); e = e.map((t, e) => this.formatCodeSegments(t)); let i = ""; return e.forEach(t => { i += t.code }), i = this.formatProperties(i), i = this.singleLineTags ? (i = this.formatCodeTextWithLevels(i), this.formatTags(i)) : (i = this.formatTags(i), this.formatCodeTextWithLevels(i)), i = this.formatSwitchCase(i), new vscode_1.TextEdit(Utilities_1.default.GetFullRangeOfDocument(t), i) } formatSelection(t, e) { var i = t.lineAt(e.start.line).range, r = t.lineAt(e.end.line).range, a = e.union(i).union(r), e = t.getText(), i = this.getBoundaryIfMatch(t, e, a.start, this.StringPattern, !0), i = this.getBoundaryIfMatch(t, e, i, this.CommentPattern, !0), r = this.getBoundaryIfMatch(t, e, a.end, this.StringPattern, !1), r = this.getBoundaryIfMatch(t, e, r, this.CommentPattern, !1), a = new vscode_1.Range(i, r), r = t.getText(a); let s = ShadeView_1.ShadeView.getCodeSegments(r); s = s.map((t, e) => this.formatCodeSegments(t)); let n = ""; s.forEach(t => { n += t.code }), n = "{" === n.trim() || "}" === n.trim() ? n.trim() : this.formatProperties(n); t = this.getLevelOfLastNonEmptyLine(t, a); return n = this.singleLineTags ? (n = this.formatCodeTextWithLevels(n, t, !0), this.formatTags(n)) : (n = this.formatTags(n), this.formatCodeTextWithLevels(n, t, !0)), n = this.formatSwitchCase(n), [new vscode_1.TextEdit(a, n)] } getLevelOfLastNonEmptyLine(r, a) { var t = a.start.line - 1; if (t <= 0) return 0; let s = 0, n = t; for (; 0 < n; n--) { let e = r.lineAt(n).text; if (e.trim()) { s = Utilities_1.default.getLevelCount(e); let t = e.trim(); (t.startsWith("{") || t.endsWith("{") || t.startsWith("#if") || t.startsWith("#el") || t.startsWith("if") || t.startsWith("el")) && s++; break } } a = a.start.line; if (2 <= a) { let t = r.lineAt(n - 1).text.trim(), e = r.lineAt(n).text.trim(), i = r.lineAt(a).text.trim(); (i.startsWith("{") && (e.startsWith("if") || e.startsWith("el")) || i.startsWith("el") && !e.startsWith("if") && !e.startsWith("}") && !e.startsWith("el") || (i.startsWith("if") || i.startsWith("#if")) && -1 != t.indexOf("else") && -1 === e.indexOf("}")) && s-- } return s } getBoundaryIfMatch(t, e, i, r, a) { for (var s = t.offsetAt(i); null !== (l = r.exec(e));) { var n = l.index, l = n + l[0].length; if (n <= s && s <= l) return a ? t.positionAt(n) : t.positionAt(l) } return i } formatCodeTextWithLevels(t, e = 0, r = !1) {
        let a = t.split(/\n/gi), s = e, n = !1, l = !1, h = 0, o = [], g = 0, c = !1, m = void 0, p = !1, d = 0, f = !1; for (let i = 0; i < a.length; i++) {
            let e = a[i]; var _; if (e = e.replace(/\r/gi, ""), s < 0 && (s = 0), e) if (e = 0 <= i - 1 && a[i - 1].trim().endsWith("\\") ? (u = s * this.tabSize, e = e.replace(/\t/gim, this.getTabByLevel(1)), -1 == (_ = Utilities_1.default.getFirstNonSpaceIndex(e)) || _ + 1 < u ? (_ = _ - _ % this.tabSize, e.substring(_)) : e.substring(u)) : e.trim(), e.startsWith("BEGIN_")) a[i] = e.trim(), s++; else if (e.startsWith("END_")) a[i] = e.trim(), s--; else {
                if (!p) { if (e.startsWith("/*") && -1 === e.indexOf("*/")) { p = !0, a[i] = this.getTabByLevel(s) + e, d = Utilities_2.default.getFirstNonSpaceIndex(this.normalizedString(a[i])); continue } if (a[i] = this.getTabByLevel(s) + e, e.startsWith("//")) continue } if (e.endsWith("*/") && p) p = !1, d = 0, a[i] = this.getTabByLevel(s) + e; else if (p) a[i] = this.getBlockCommentFormattedString(a[i], s, d); else {
                    switch (this.alignMacroMode) { case IndentationType.identWithHierachy: if (this.isMacroLine(e) && !l && !r) { l = !0, e.startsWith("#if") && (h = s, o.push(h), 0 < s && (s += 1)); continue } if (e.startsWith("#if")) { l || 0 != s ? s += 1 : l = !0, o.push(Math.max(s - 1, 0)); continue } if (this.isMacroLine(e)) { h = 0 < o.length ? o[o.length - 1] : s, e.startsWith("#endif") ? (a[i] = this.getTabByLevel(h) + e, s = h, o.pop()) : e.startsWith("#el") && (a[i] = this.getTabByLevel(h) + e, s = h + 1); continue } break; case IndentationType.noIndentWithHierachy: if (this.isMacroLine(e) && !l && !r) { a[i] = this.getTabByLevel(h) + e, l = !0, !e.startsWith("#if") || e.startsWith("#ifd") || e.startsWith("#ifn") || (h += 1); continue } if (this.isMacroLine(e)) { if (e.startsWith("#if")) { if (a[i] = this.getTabByLevel(h) + e, h += 1, 0 < i) { let t = a[i - 1].trim(); this.isMacroLine(t) && !t.startsWith("#en") && s < h && (g += 1, s += 1) } continue } e.startsWith("#endif") ? (a[i] = this.getTabByLevel(h - 1) + e, 0 <= g && (s -= 1, g -= 1), h = Math.max(h - 1, 0)) : e.startsWith("#else") || e.startsWith("#elif") ? a[i] = this.getTabByLevel(h - 1) + e : a[i] = this.getTabByLevel(h) + e; continue } break; case IndentationType.indentWithoutHierachy: if (e.startsWith("#if")) { o.push(Math.max(s - 1, 0)), a[i] = this.getTabByLevel(o[o.length - 1]) + e; continue } if (this.isMacroLine(e)) { h = 0 < o.length ? o[o.length - 1] : s, a[i] = this.getTabByLevel(h) + e, e.startsWith("#endif") && o.pop(); continue } break; case IndentationType.noIndentWithoutHierachy: if (this.isMacroLine(e)) { a[i] = e; continue } }if (this.placeBraceOnNewLine) { if (e.endsWith("{") && !e.startsWith("#")) { s += 1; continue } } else if (e.endsWith("{")) {
                        var u = e.startsWith(")") || e.endsWith(") {"); e.startsWith("}") ? a[i] = this.getTabByLevel(s - 1) + e : u && n ? (e.startsWith(")") ? a[i] = this.getTabByLevel(s - 1) + e : a[i] = this.getTabByLevel(s) + e.replace(") {", `\r
${this.getTabByLevel(s - 1)}) {`), n = !1) : s += 1; continue
                    } if ((e.startsWith("case") || e.startsWith("default")) && e.endsWith(":") && (s++, f = !0), f && (e.startsWith("return") || e.replace(/;/g, "").trim().endsWith("break")) && (s--, f = !1), !e.startsWith("/#") && !e.startsWith("/*") && !e.startsWith("//") && !e.startsWith("*") && e.endsWith("(") && !e.startsWith("#")) s += 1, n = !0; else if (n) e.startsWith(")") ? (a[i] = this.getTabByLevel(s - 1) + e, s -= 1, n = !1) : (e.endsWith(")") || e.replace(/\s/gm, "").endsWith(");")) && (s -= 1, n = !1); else if (e.startsWith("#endif") || e.startsWith("}") && 0 < i && !a[i - 1].trim().endsWith("\\")) a[i] = this.getTabByLevel(s - 1) + e, s -= 1; else if (e.startsWith("#else") || e.startsWith("#elif")) a[i] = this.getTabByLevel(s - 1) + e; else { if (!this.keepMacroMethodsLevel) { if (c && m && e.startsWith(MACRO_METHODS_PAIR[m])) { a[i] = this.getTabByLevel(s - 1) + e, s -= 1, c = !1, m = void 0; continue } if (!m && !c) { for (var W in MACRO_METHODS_PAIR) if (new RegExp(W + "\\s*\\([\\s\\S]+?\\)").test(e)) { c = !0, m = W; break } if (c && m) { s += 1; continue } } } if (0 < i) { let t = a[i - 1].trim(); (t.endsWith(")") || t.startsWith("else")) && (t.startsWith("if") || t.startsWith("else if") || 0 <= i - 2 && (-1 != a[i - 2].trim().indexOf("&&") || -1 != a[i - 2].trim().indexOf("||")) || -1 != t.indexOf("&&") || -1 != t.indexOf("||")) && !ShadeView_1.ShadeView.IsProperties(e) && !t.startsWith("#") && !t.startsWith("//") ? e.startsWith("else") || (a[i] = this.getTabByLevel(s + 1) + e) : (t.startsWith("else") && !t.endsWith("{") || t.endsWith("else") && !t.startsWith("#")) && (a[i] = this.getTabByLevel(s + 1) + e) } }
                }
            } else a[i] = e
        } return a.join("\r\n")
    } normalizedString(t) { return t.replace(/\t/g, this.getRepeatText(" ", this.tabSize)) } getBlockCommentFormattedString(e, t, i) { var r = this.normalizedString(e), r = Utilities_1.default.getFirstNonSpaceIndex(r); if (r <= i) return this.getTabByLevel(t) + e.trim(); var a = r - i; if ("\t" != this.tabs) return this.getTabByLevel(t) + this.getRepeatText(" ", a) + e.trim(); i = Utilities_1.default.getFirstNonSpaceIndex(e); if (0 < i) { var s = 0, n = -1; for (let t = i - 1; 0 <= t; t--)if ("\t" == e[t] ? s += this.tabSize : s += 1, a == s) { n = t; break } return 0 <= n ? this.getTabByLevel(t) + e.substr(n).replace(/\r/g, "") : this.getTabByLevel(t) + e.trim() } return this.getTabByLevel(t) + e.trim() } isMacroLine(t) { return t.startsWith("#") && !t.startsWith("#pragma") && !t.startsWith("#include") } formatCodeSegments(t) { let e = t.code; if (t.type === ShadeView_1.CodeSegmentType.Comment) return t; if (t.type === ShadeView_1.CodeSegmentType.String) return t; { let r = e.split(/\n/gi), a = ""; for (let i = 0; i < r.length; i++) { let t = r[i], e = t.trim(); (e.trim().startsWith("#define") || a.endsWith("\\")) && (t = t.replace(/\{/gi, "____shadeviewvscode__zdakuohao__awwsky__"), t = t.replace(/\}/gi, "____shadeviewvscode__ydakuohao__awwsky__"), r[i] = t), a = e } e = r.join("\n"), e = this.formatSymbols(e), e = this.formatProgramClourse(e), e = this.formatControlFlow(e), e = this.formatMacros(e), e = e.replace(/____shadeviewvscode__zdakuohao__awwsky__/gi, "{"), e = e.replace(/____shadeviewvscode__ydakuohao__awwsky__/gi, "}") } return new ShadeView_1.CodeSegments(e, t.type) } formatControlFlow(t) {
        var e = this.placeBraceOnNewLine ? "\r\n" : " "; let i = t.replace(/\)[ \t]*{[ \t]*}/gm, `)${e}{ \r
\r
}`); return i = i.replace(/else[ \t]*{[ \t]*}/gm, `else${e}{ \r
\r
}`), i = i.replace(/\}[ \t\r\n]*else/gm, `}${e}else`), i = i.replace(/do[ \t]*{[ \t]*}/gm, `do${e}{ \r
\r
}`), i = i.replace(/if[ \t]*\(/gm, "if ("), i = i.replace(/while[ \t]*\(/gm, "while ("), i = i.replace(/}[ \t]*while[ \t]*\(/gm, "} while ("), i = i.replace(/for\s*\(([\s\S]*?)\s*;\s*([\s\S]*?)\s*;\s*([\s\S]*?)\s*?\)/gm, "for ($1; $2; $3)"), i
    } formatProgramClourse(t) { return t.replace(/(\n?)[ \t]*?(CGPROGRAM|ENDCG|GLSLPROGRAM|ENDGLSL|HLSLPROGRAM|ENDHLSL)([ \t]*)([\r\n]+)/gim, "$1$2$4") } formatTags(t) {
        var e = this.singleLineTags ? " " : "\r\n"; let i = t.replace(/\s*(\/[\/|\*]\s]*)*"(RenderPipeline|RenderType|Queue|DisableBatching|ForceNoShadowCasting|IgnoreProjector|CanUseSpriteAtlas|PreviewType|LightMode|PassFlags|RequireOptions)"/gim, e + '$1"$2"'); return i = this.singleLineTags ? i.replace(/(Tags|tags)\s*?{\s*([ \t\r\n\S]*?)\s*}([\r\n]?)/gim, "$1 { $2 }$3") : (e = this.placeBraceOnNewLine ? "\r\n" : " ", i.replace(/(Tags|tags)\s*?{\s*([ \t\r\n\S]*?)\s*}([\r\n]?)/gim, `$1${e}{\r
$2\r
}$3`)), i
    } formatSymbols(t) {
        var e = this.placeBraceOnNewLine ? "\r\n" : " "; let i = t.replace(/\s*{[ \t]*\r?\n?/gim, e + `{\r
`); return i = i.replace(/\s*}[ \t]?/gim, "\r\n}"), i = i.replace(/\s*{\s*}/gim, " { }"), i = this.formatSemicolon(i), i = this.formatLineSymbols(i), i
    } formatSemicolon(t) { let e = t.replace(/}\s*;\r?\n?/gim, "};\r\n"); return e = e.replace(/;\s*\\/gim, "; \\"), e } formatMacros(t) { return t.replace(/#[ \t]+?(if|elif|else|endif)+/gi, "#$1") } formatSwitchCase(t) { let e = t.replace(/case[ \t]+(\S+)*[ \t]*:/gi, "case $1:"); return e = e.replace(/default[ \t]*:/gi, "default:"), e } formatLineSymbols(t) { let e = t.replace(/(#define)[ \t]+([\w\d_]+)[ \t]/gim, "$1 $2______shadeviewvscode________awwsky__________"); e = e.replace(/[ \t]*\([ \t]*/gim, "("), e = e.replace(/______shadeviewvscode________awwsky__________/gim, " "), e = e.replace(/\s*=\s*/gim, " = "), e = e.replace(/#include\s*?\"([\s\S]+?)"/gm, function (t) { let e = t.replace(/\//gm, "{"); return e = e.replace(/-/gm, "}"), e }), e = e.replace(/[ \t]*-[ \t]*/gim, " - "), e = e.replace(/[ \t]*:[ \t]*/gim, " : "), e = e.replace(/([a-zA-Z0-9_]+)[ \t]*:[ \t]*:[ \t]*([a-zA-Z0-9_]+)/, "$1::$2"), e = e.replace(/[ \t]*\+[ \t]*/gim, " + "), e = e.replace(/[ \t]*>[ \t]*/gim, " > "), e = e.replace(/[ \t]*<[ \t]*/gim, " < "), e = e.replace(/[ \t]*<[ \t]*?([a-zA-Z0-9_]+)[ \t]*?>/gim, "<$1>"), e = e.replace(/[ \t]*\*[ \t]*/gim, " * "), e = e.replace(/[ \t]*\/[ \t]*/gim, " / "), e = e.replace(/[ \t]*%[ \t]*/gim, " % "), e = e.replace(/[ \t]*&[ \t]*/gim, " & "), e = e.replace(/[ \t]*\|[ \t]*/gim, " | "), e = e.replace(/[ \t]*\)/gim, ")"), e = e.replace(/[ \t]*\/[ \t]*\/[ \t]*/gim, " // "), e = e.replace(/\)\(/gim, ") ("), e = e.replace(/[ \t]*>[ \t]*>[ \t]*/gim, " >> "), e = e.replace(/[ \t]*<[ \t]*<[ \t]*/gim, " << "), e = e.replace(/[ \t]*-[ \t]*-[ \t]*/gim, " -- "), e = e.replace(/([a-zA-Z0-9_]*?)[ \t]\-\-[ \t]([a-zA-Z0-9_]*?)/gim, "$1--$2"), e = e.replace(/[ \t]*\+[ \t]*\+[ \t]*/gim, " ++ "), e = e.replace(/([a-zA-Z0-9_]*?)[ \t]\+\+[ \t]([a-zA-Z0-9_]*?)/gim, "$1++$2"), e = e.replace(/[ \t]*=[ \t]*/gim, " = "), e = e.replace(/[ \t]*-[ \t]*=[ \t]*/gim, " -= "), e = e.replace(/[ \t]*\*[ \t]*=[ \t]*/gim, " *= "), e = e.replace(/[ \t]*=[ \t]*=[ \t]*/gim, " == "), e = e.replace(/[ \t]*&[ \t]*&[ \t]*/gim, " && "), e = e.replace(/[ \t]*\|[ \t]*\|[ \t]*/gim, " || "), e = e.replace(/[ \t]*\+[ \t]*=[ \t]*/gim, " += "), e = e.replace(/[ \t]*<[ \t]*=[ \t]*/gim, " <= "), e = e.replace(/[ \t]*>[ \t]*=[ \t]*/gim, " >= "), e = e.replace(/[ \t]*\/[ \t]*=[ \t]*/gim, " /= "), e = e.replace(/[ \t]*![ \t]*=[ \t]*/gim, " != "), e = e.replace(/[ \t]*&[ \t]*=[ \t]*/gim, " &= "), e = e.replace(/[ \t]*\|[ \t]*=[ \t]*/gim, " |= "), e = e.replace(/[ \t]*\^[ \t]*=[ \t]*/gim, " ^= "), e = e.replace(/[ \t]*%[ \t]*=[ \t]*/gim, " %= "), e = e.replace(/[ \t]*<[ \t]*<[ \t]*=[ \t]*/gim, " <<= "), e = e.replace(/[ \t]*>[ \t]*>[ \t]*=[ \t]*/gim, " >>= "), e = e.replace(/[ \t]*\+[ \t]*\+[ \t]*=[ \t]*=[ \t]*/gim, "++ == "), e = e.replace(/[ \t]*-[ \t]*-[ \t]*=[ \t]*=[ \t]*/gim, "-- == "), e = e.replace(/[ \t]*?,[ \t]*/gim, ", "), e = e.replace(/[ \t]*\?[ \t]*/gim, " ? "), e = e.replace(/(\d+)e[ \t]*-[ \t]*(\d+)/gim, "$1e-$2"), e = e.replace(/(=)[ \t]*(-|\+)[ \t]*(\w+)/gim, "$1 $2$3"), e = e.replace(/(return)[ \t]*(-|\+)[ \t]*(\w+)/gim, "$1 $2$3"), e = e.replace(/(,)[ \t]*(-|\+)[ \t]*(\w+)/gim, "$1 $2$3"), e = e.replace(/(\()[ \t]*(-|\+)[ \t]*(\w+)/gim, "$1$2$3"), e = e.replace(/(offset)[ \t]*(-|\+)[ \t]*(\w+)/gim, "$1 $2$3"), e = e.replace(/(#define)[ \t]*([\w\d_]+)[ \t]*([-+])[ \t]*(\w)/gm, "$1 $2 $3$4"), e = e.replace(/(\s*--)([_|\w]+)+/gm, " - -$2"), e = e.replace(/(return)[ \t]*\(/gm, "return ("), e = e.replace(/(\S*?)\s*<\s*(\S*)\s*>\s*(\S*)\s*?(;)/gim, "$1<$2> $3$4"), e = e.replace(/(\S*?)\s*<\s*(\S*)\s*>\s*(\S*)\s*?(=)/gim, "$1<$2> $3 $4"); for (let t = 0; t < 10; t++)e = e.replace(/(#[\w: \t]+?)([\s]+?):[ \t]+/gim, "$1:"); return e = e.replace(/(return|uniform|struct|sampler|sampler2D|sampler3D|samplerCUBE|string|triangle|triangleadj|vector|((float|int|uint|bool|half|fixed|double)(\d*?|\d*?x\d*?)))[ \t]+(\w+)/gim, "$1 $5"), e = e.replace(/#include\s*?\"([\s\S]+?)"/gm, function (t) { let e = t.replace(/\{/gm, "/"); return e = e.replace(/\}/gm, "-"), e }), e } formatProperties(t) { return t.replace(/([\S]*?)\s*?\("([\s\S]*?)"\s*,\s*([\s\S]+?)\)\s*=/gim, '$1 ("$2", $3) =') } getTabByLevel(t) { return this.getRepeatText(this.tabs, t = t < 0 ? 0 : t) } getRepeatText(e, i) { let r = ""; if (!e || i < 0) return r; for (let t = 0; t < i; t++)r += e; return r }
} exports.default = Formatter;