"use strict"; Object.defineProperty(exports, "__esModule", { value: !0 }); const vscode_1 = require("vscode"), ShadeView_1 = require("./ShadeView"); let diagnosticsCollections, updatehandler; class SLDiagnosticProvider { static register(t) { diagnosticsCollections = vscode_1.languages.createDiagnosticCollection("ShadeView_Diagnostics"), t.subscriptions.push(vscode_1.workspace.onDidOpenTextDocument(t => this.didOpenTextDocument(t))), t.subscriptions.push(vscode_1.window.onDidChangeActiveTextEditor(t => this.onDidChangeActiveEditor(t))), t.subscriptions.push(vscode_1.workspace.onDidChangeTextDocument(t => this.didChangeTextDocument(t))), t.subscriptions.push(vscode_1.workspace.onDidCloseTextDocument(t => this.didCloseTextDocument(t))), this.updateCurrentDocumentDiagnostics() } static updateCurrentDocumentDiagnostics() { vscode_1.window.activeTextEditor && this.updateDiagnosticsAsync(vscode_1.window.activeTextEditor.document) } static getDiagnosticEnable() { let t = vscode_1.workspace.getConfiguration(); return t.get("diagnostics.enable") } static onDidChangeActiveEditor(t) { t && this.updateDiagnosticsAsync(t.document) } static didOpenTextDocument(t) { this.updateDiagnosticsAsync(t) } static didCloseTextDocument(t) { this.deleteDiagnostics(t) } static didChangeTextDocument(t) { t && this.updateDiagnosticsAsync(t.document) } static deleteDiagnostics(t) { diagnosticsCollections.delete(t.uri) } static updateDiagnosticsAsync(t) { ShadeView_1.ShadeView.IsDisabled(t) || (clearTimeout(updatehandler), updatehandler = setTimeout(() => this._updateDiagnostics(t), 600)) } static _updateDiagnostics(e) { if (e && "shadeview" == e.languageId) if (this.getDiagnosticEnable()) { let t = [new InvalidSymbolsRule]; t.forEach(t => { 0 == t.getDiagnostics(e).length ? diagnosticsCollections.delete(e.uri) : diagnosticsCollections.set(e.uri, t.getDiagnostics(e)) }), updatehandler = void 0 } else diagnosticsCollections.clear() } } exports.default = SLDiagnosticProvider; class DiagnosticRuleBase { } class TextRange { constructor(t, e) { this.start = t, this.end = e } contains(t) { return t.start >= this.start && t.end <= this.end && this.end >= this.start && t.end >= t.start } } class InvalidSymbolsRule { getDiagnostics(a) { let o = []; var t = this.getPatternMatchRanges(/[^\w\s/\."'+<>\|\[\]\\,\/#!\?$%\^&\*;:{}=\-_`~()]+/gim, a); if (0 == t.length) return []; let c = []; return c.push(...this.getPatternMatchRanges(/(\/\*(\*(?!\/)|[^*])*\*\/|\/\/.+[\r\n])/gim, a)), c.push(...this.getPatternMatchRanges(/"[^\n]*?(?<!\\)"/gim, a)), t.forEach(t => { let e = !1; for (const n of c) if (n.contains(t)) { e = !0; break } var s, i; e || (s = a.positionAt(t.start), i = a.positionAt(t.end + 1), i = new vscode_1.Range(s, i), i = { message: `Invalid symbols '${a.getText(i).trim()}'`, severity: vscode_1.DiagnosticSeverity.Error, range: i }, o.push(i)) }), o } getPatternMatchRanges(t, e) { let s = []; for (var i = e.getText(); n = t.exec(i);) { var n = new TextRange(n.index, n.index + n[0].length); s.push(n) } return s } }